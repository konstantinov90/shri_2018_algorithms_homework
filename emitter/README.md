## Первое задание: генератор событий
Реализовать генератор событий, имеющий следующие методы
* подписка на событие — **on**
* отписка от события — **off**
* вызов события — **emit**

```
const emitter = {
   on: function(event, handler) {
      // TODO: подписать
   },
   
   off: function(event, handler) {
      // TODO: отписать
   },
   
   emit: function(event) {
      // TODO: обработка события
   }
}

const handler = function () {
  // что-то делаем
};

// подписали
emitter.on('event', handler);
// обработали событие
emitter.emit('event');
// отписали
emitter.off('event', handler);
```

А так же оценить сложность получившихся методов.

**Дополнительные условия и ограничения:**
- Обработчики должны возникать в том порядке, в котором их подписали
- Подписка, отписка и вызов обработчиков должны работать максимально быстро
- Ограничений по дополнительной памяти нет, но чем меньше, тем лучше
- Считаем, что на вход данные подаются хорошие, т.е. event - строка, handler - функция.
--------------------------

### Решение

В этом решении все предельно просто. Массив обработчиков хранится в объекте типа _Array_ (для обеспечения сохранения порядка). Хранятся эти массивы в объекте типа _Map_, что обеспечиват максимально простой доступ (амортизированное _O(1)_). Соответственно, обработка евента (вызов всех обработчиков) имеет сложность _O(N)_, где _N_ – количество обработчиков данного евента. Выбросить обработчик из массива тоже стоит _O(N)_ (_N_ – то же, что и выше) , так как нужно отыскать его в массиве.

Обработчики могут быть как обычными функциями, так и функциями, отдающими _Promise_. Выполняются они последовательно.

Пример работы эмиттера можно посмотреть, выполнив
```
npm run test:emitter
```
