## Задание: саджест

Есть большой массив названий улиц, и инпут на сайте, в котором эту улицу нужно выбрать. При вводе пользователю предлагается до 10 улиц, в названии которых есть введенная пользователем подстрока без учета регистра (т.е. на ввод "тверская" должно найтись "ул. Тверская").
Нужно реализовать функцию, которая принимает на вход строку input, и возвращает массив найденных улиц(не больше 10).

```
const roads = [
  'ул. Тверская',
  'ул. Ломоносова',
  'проспект Сахарова'
  // и еще много-много улиц
];

function suggest(input) {
  // поиск улиц
}
```

И оценить сложность получившейся функции.

**Дополнительные условия и ограничения**:

- Поиск должен работать максимально быстро
- Ограничений по дополнительной памяти нет, но чем меньше, тем лучше
- Считаем, что на вход данные подаются хорошие, input - строка.

--------------------------

### Решение

Для поиска подстроки в строке в JS есть два способа:
- метод `String.prototype.includes` (загримированный `indexOf`) 
- регулярные выражения

производительность этих методов исследована в скриптах

`npm run test:indexof`

и

`npm run test:regexp`.

Видно, что регулярные выражения замедляются c увеличением строки примерно как _O(N<sup>2</sup>)_, в которой ведется поиск (стог сена - `haystack`), при этом размер иголки (`needle`) на сложность алгоритма не влияет. Также видно, что алгоритм `indexOf` зависит от размера стога сена максимум как _O(log(N))_, а может быть и как _O(1)_!.

Следовательно, для данной задачи регулярные выражения выбирать не имеет смысла.

К перебору наименовений улиц с целью применить к ним алгоритм поиска также есть два подхода:
- "в лоб"

    ```
    function headlongSolution(_input) {
    const input = _input.toLowerCase();
    return streets.filter(s => s.toLowerCase().includes(input)).slice(0, 10);
    }
    ```

- искать, пока не найдем подходящие 10 строк и на этом останавливаться

    ```
    function elaborateSolution(_input) {
    const limit = 10;
    const input = _input.toLowerCase();
    const result = [];
    let found = 0;
    
    for (street of streets) {
        if (street.toLowerCase().includes(input)) {
        result[found++] = street;
        if (found === limit) {
            break
        }
        }
    }
    return result;
    }
    ```


Видно, что в первом случае алгоритм поиска будет применен ко всем без исключения улицам, откуда следует сложность _O(N)_, да еще и оверхэд по памяти, в пределе также достигающий _O(N)_.

Для второго алгоритма сложность составляет в лучшем случае _O(1)_ (если искомая строка найдется в первых десяти улицах) и в пределе достигает _O(N)_, когда придется перебирать все улицы. Оверхэда по памяти нет.

Сложность работы этих методов можно оценить, запустив скрипт:

```
npm run test:streets
```
